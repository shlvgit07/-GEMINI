import { Term } from "../types";

export const DICTIONARY_TERMS: Term[] = [
  // --- Pseudo Code (הוראות מחשב) ---
  {
    id: 'p1',
    title: 'השמה (Assignment)',
    category: 'pseudo',
    description: 'הכנסת ערך לתוך משתנה. בדרך כלל מחליפה את הערך הקודם שהיה בו.',
    codeExample: `1. שים ב-A את המספר 5
2. שים ב-B את הערך של A + 2
// בסוף: A=5, B=7`,
    explanation: 'הפקודה "שים ב..." או "=" מעדכנת את הזיכרון של המשתנה. כל ערך שהיה ב-A לפני כן נמחק.'
  },
  {
    id: 'p2',
    title: 'תנאי (If/Else)',
    category: 'pseudo',
    description: 'ביצוע פקודות רק אם מתקיים תנאי מסוים.',
    codeExample: `1. שים ב-X את 10
2. אם X > 5 אז:
3.    חסר מ-X את 2
4. אחרת:
5.    הוסף ל-X את 2
// בסוף: X=8 (כי 10 גדול מ-5)`,
    explanation: 'המחשב בודק את התנאי. אם הוא אמת - מבצע את הבלוק הראשון. אם שקר - מבצע את הבלוק של "אחרת" (אם קיים).'
  },
  {
    id: 'p3',
    title: 'לולאה (Loop/While)',
    category: 'pseudo',
    description: 'חזרה על קטע קוד כל עוד תנאי מסוים מתקיים.',
    codeExample: `1. שים ב-K את 0
2. כל עוד K < 3 בצע:
3.    הוסף ל-K את 1
4. סוף לולאה
// הלולאה תרוץ 3 פעמים. בסוף K=3`,
    explanation: 'לולאת "כל עוד" בודקת את התנאי לפני כל הרצה. ברגע ש-K מגיע ל-3, התנאי (3 < 3) הוא שקר והלולאה מסתיימת.'
  },
  {
    id: 'p4',
    title: 'קפיצה (Jump/Goto)',
    category: 'pseudo',
    description: 'דילוג לשורה אחרת בקוד, לעיתים קרובות בשילוב עם תנאי.',
    codeExample: `1. שים ב-A את 1
2. הוסף ל-A את 1
3. אם A < 4 עבור לשורה 2
4. הדפס A
// הקוד יחזור לשורה 2 פעמיים נוספות. בסוף יודפס 4`,
    explanation: 'פקודת "עבור ל..." משנה את סדר הריצה הרגיל (מלמעלה למטה) ומאפשרת ליצור לולאות בצורה ידנית.'
  },
  {
    id: 'p5',
    title: 'מערך (Array)',
    category: 'pseudo',
    description: 'אוסף של משתנים תחת שם אחד, כאשר ניגשים לכל אחד מהם לפי אינדקס (מיקום).',
    codeExample: `ARR = [10, 20, 30]
שים ב-X את ARR[0]  // X יקבל 10
שים ב-ARR[1] את 50 // המערך יהיה [10, 50, 30]`,
    explanation: 'זכור! במדעי המחשב הספירה מתחילה לרוב מ-0. האיבר הראשון הוא באינדקס 0.'
  },
  {
    id: 'p6',
    title: 'מודולו (Modulo)',
    category: 'pseudo',
    description: 'פעולה המחשבת את שארית החלוקה.',
    codeExample: `A = 10 Mod 3
// 10 לחלק ל-3 זה 3 עם שארית 1.
// לכן A יהיה שווה ל-1.`,
    explanation: 'שימושי מאוד לבדיקת זוגיות (Mod 2) או למחזוריות.'
  },
  {
    id: 'p7',
    title: 'החלפת משתנים (Swap)',
    category: 'pseudo',
    description: 'טכניקה להחלפת ערכים בין שני משתנים באמצעות משתנה עזר.',
    codeExample: `TEMP = A
A = B
B = TEMP
// כעת הערכים של A ו-B הוחלפו`,
    explanation: 'אי אפשר פשוט לכתוב A=B ואז B=A, כי הפקודה הראשונה דורסת את הערך המקורי של A. חייבים "לשמור בצד" את הערך במשתנה זמני.'
  },
  {
    id: 'p8',
    title: 'לוגיקה בוליאנית (AND/OR/NOT)',
    category: 'pseudo',
    description: 'פעולות לוגיות המחזירות אמת או שקר, משמשות בתנאים מורכבים.',
    codeExample: `אם (A > 5) וגם (B < 3):
   // יתבצע רק אם שני התנאים נכונים
אם (A > 5) או (B < 3):
   // יתבצע אם לפחות אחד מהם נכון`,
    explanation: 'AND (וגם) דורש שכולם יהיו אמת. OR (או) מסתפק באחד. NOT (לא) הופך את התוצאה.'
  },
  {
    id: 'p9',
    title: 'לולאה מקוננת (Nested Loop)',
    category: 'pseudo',
    description: 'לולאה בתוך לולאה. הלולאה הפנימית רצה במלואה עבור כל סיבוב של הלולאה החיצונית.',
    codeExample: `עבור I מ-1 עד 3:
   עבור J מ-1 עד 3:
      הדפס I,J
// יודפס: 1,1 | 1,2 | 1,3 | 2,1 ...`,
    explanation: 'מספר הפעולות הכולל הוא מכפלת מספר האיטרציות. כאן: 3 כפול 3 = 9 ריצות סה"כ.'
  },

  // --- Algorithms (אלגוריתמים ומבני נתונים) ---
  {
    id: 'a1',
    title: 'מחסנית (Stack)',
    category: 'algo',
    description: 'מבנה נתונים מסוג LIFO (Last In, First Out). האחרון שנכנס הוא הראשון שיוצא.',
    codeExample: `Stack S = []
Push(S, 1) // S: [1]
Push(S, 2) // S: [1, 2]
X = Pop(S) // X=2, S: [1]`,
    explanation: 'דמיינו ערימה של צלחות. תמיד מורידים את הצלחת העליונה (זו שהונחה אחרונה).'
  },
  {
    id: 'a2',
    title: 'תור (Queue)',
    category: 'algo',
    description: 'מבנה נתונים מסוג FIFO (First In, First Out). הראשון שנכנס הוא הראשון שיוצא.',
    codeExample: `Queue Q = []
Enqueue(Q, 1) // Q: [1]
Enqueue(Q, 2) // Q: [1, 2]
X = Dequeue(Q) // X=1, Q: [2]`,
    explanation: 'בדיוק כמו תור בסופר. מי שהגיע ראשון - יוצא ראשון.'
  },
  {
    id: 'a3',
    title: 'רקורסיה (Recursion)',
    category: 'algo',
    description: 'פונקציה הקוראת לעצמה עד שהיא מגיעה לתנאי עצירה.',
    codeExample: `פונקציה F(n):
  אם n == 0 החזר 0
  אחרת, החזר n + F(n-1)

// עבור F(3) נקבל: 3 + 2 + 1 + 0 = 6`,
    explanation: 'רקורסיה מפרקת בעיה גדולה לבעיות קטנות יותר מאותו הסוג.'
  },
  {
    id: 'a4',
    title: 'מיון בועות (Bubble Sort)',
    category: 'algo',
    description: 'אלגוריתם מיון פשוט המחליף זוגות סמוכים אם הם לא בסדר הנכון.',
    codeExample: `מערך: [5, 1, 4]
סיבוב 1: [1, 5, 4] (החלפה בין 5 ל-1)
סיבוב 2: [1, 4, 5] (החלפה בין 5 ל-4)`,
    explanation: 'המספרים "הכבדים" (הגדולים) מבעבעים לסוף המערך בכל איטרציה.'
  },
  {
    id: 'a5',
    title: 'חיפוש בינארי (Binary Search)',
    category: 'algo',
    description: 'שיטה יעילה למציאת ערך ברשימה ממוינת על ידי חציית החיפוש בכל שלב.',
    codeExample: `רשימה: [2, 4, 6, 8, 10, 12, 14]
מחפשים 10:
1. אמצע = 8. 10 > 8, הולכים ימינה.
2. אמצע = 12. 10 < 12, הולכים שמאלה.
3. מצאנו את 10!`,
    explanation: 'עובד רק כשהרשימה מסודרת. מהיר הרבה יותר מלעבור אחד אחד.'
  },
  {
    id: 'a6',
    title: 'מונה וצובר (Counter & Accumulator)',
    category: 'algo',
    description: 'משתנים נפוצים בלולאות: מונה סופר פעמים (C=C+1), צובר מסכם ערכים (Sum=Sum+X).',
    codeExample: `Count = 0, Sum = 0
עבור כל ציון ברשימה:
   Count = Count + 1
   Sum = Sum + ציון
ממוצע = Sum / Count`,
    explanation: 'המונה משמש לדעת "כמה יש", הצובר משמש לדעת "כמה סה״כ".'
  },
  {
    id: 'a7',
    title: 'עץ בינארי (Binary Tree)',
    category: 'algo',
    description: 'מבנה נתונים היררכי שבו לכל צומת יש עד שני "ילדים" (שמאל וימין).',
    codeExample: `      5
    /   \
   3     8
  / \   /
 1   4 7`,
    explanation: 'משמש רבות לחיפוש ומיון. השורש למעלה, העלים למטה.'
  },

  // --- Logic (לוגיקה וחשיבה) ---
  {
    id: 'l1',
    title: 'סדרת הפרשים',
    category: 'logic',
    description: 'סדרה שבה ההפרש בין האיברים הוא קבוע או משתנה בחוקיות מסוימת.',
    codeExample: `2, 5, 8, 11... (הפרש קבוע +3)
2, 4, 8, 14... (הפרשים: +2, +4, +6...)`,
    explanation: 'תמיד חשב את ההפרש בין כל זוג מספרים סמוך כדי למצוא את החוקיות.'
  },
  {
    id: 'l2',
    title: 'סדרת דילוגים',
    category: 'logic',
    description: 'שתי סדרות שונות המשולבות זו בזו לסירוגין.',
    codeExample: `10, 2, 20, 4, 30, 6...
סדרה א (מקומות אי זוגיים): 10, 20, 30...
סדרה ב (מקומות זוגיים): 2, 4, 6...`,
    explanation: 'אם הסדרה נראית ארוכה ולא הגיונית, נסה לבדוק את האיברים במקומות הזוגיים והאי-זוגיים בנפרד.'
  },
  {
    id: 'l3',
    title: 'סדרה הנדסית (Geometric)',
    category: 'logic',
    description: 'סדרה בה כל איבר מתקבל על ידי הכפלת האיבר הקודם במספר קבוע.',
    codeExample: `3, 6, 12, 24, 48...
כאן כופלים כל פעם ב-2.`,
    explanation: 'שים לב אם המספרים גדלים בקצב מהיר מאוד - זה רמז לכפל ולא לחיבור.'
  },
  {
    id: 'l4',
    title: 'סדרת פיבונאצ׳י (Fibonacci)',
    category: 'logic',
    description: 'סדרה שבה כל איבר הוא סכום שני האיברים הקודמים לו.',
    codeExample: `1, 1, 2, 3, 5, 8, 13...
1+1=2
1+2=3
2+3=5`,
    explanation: 'דפוס נפוץ מאוד במבחני לוגיקה. תמיד בדוק אם איבר הוא סכום קודמיו.'
  },
  {
    id: 'l5',
    title: 'היקש לוגי (Syllogism)',
    category: 'logic',
    description: 'הסקת מסקנה משתי טענות או יותר.',
    codeExample: `טענה א: כל העננים לבנים.
טענה ב: דני הוא ענן.
מסקנה: דני הוא לבן.`,
    explanation: 'במבחנים, הטענות עשויות להיות דמיוניות ("כל החרגולים סגולים"). התמקד בלוגיקה הפורמלית ולא באמת המציאותית.'
  }
];